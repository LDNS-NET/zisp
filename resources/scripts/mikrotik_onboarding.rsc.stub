# ================= ZiSP RouterOS v7+ Onboarding Script =================
# Generated for router: {{name}}
# Router ID: {{router_id}}

:local username "{{username}}"
:local password "{{router_password}}"
:local apiPort "{{api_port}}"
:local radiusSecret "{{radius_secret}}"
:local radiusIp "{{radius_ip}}"
:local trustedIp "{{trusted_ip}}"
:local wgServerEndpoint "{{wg_server_endpoint}}"
:local wgServerPubKey "{{wg_server_pubkey}}"
:local wgSubnet "{{wg_subnet}}"
:local wgPort "{{wg_port}}"
:local wgClientIp "{{wg_client_ip}}"
:local syncUrl "{{sync_url}}"
:local wgRegisterUrl "{{wg_register_url}}"

:put "==================== ZiSP MIKROTIK ONBOARDING ===================="

# ---------- Connectivity check ----------
:if ([/ping 8.8.8.8 count=3] = 0) do={
    :put "Warning: No internet connection detected!"
} else={
    :put "Internet connectivity: OK"
}

# ---------- Router Identity ----------
/system identity set name="{{name}}"
:put "Router identity set to: {{name}}"

# ---------- Display Router IPs ----------
:put "Router IP addresses:"
:foreach id in=[/ip address find] do={
    :local ipAddr [/ip address get $id address]
    :put " - $ipAddr"
}

# ---------- RADIUS Configuration ----------
:put "==================== RADIUS CONFIGURATION ===================="

# Remove any existing RADIUS configurations for our server
:do {
    /radius remove [find address=$radiusIp]
} on-error={}

# Determine which services need RADIUS
:local radiusServices "ppp"
:do {
    /ip hotspot print
    :set radiusServices "ppp,hotspot"
    :put "Hotspot detected, enabling RADIUS for PPP and Hotspot"
} on-error={
    :put "Enabling RADIUS for PPP only (no Hotspot detected)"
}

# Add RADIUS server configuration
:do {
    /radius add service=$radiusServices address=$radiusIp secret=$radiusSecret timeout=3000ms accounting-port=1813 authentication-port=1812 use-ipv6=no disabled=no
    :put "RADIUS server configured for services: $radiusServices"
} on-error={
    :put "Warning: Could not configure RADIUS server"
}

# Configure PPP to use RADIUS
:do {
    /ppp aaa set use-radius=yes accounting=yes interim-update=1h
    :put "PPP AAA configured to use RADIUS"
} on-error={
    :put "Warning: Could not configure PPP AAA"
}

# Configure Hotspot to use RADIUS if present
:if ([:find $radiusServices "hotspot"] >= 0) do={
    :do {
        /ip hotspot profile set [find default=yes] use-radius=yes
        :put "Hotspot profile updated to use RADIUS"
    } on-error={
        :put "Warning: Could not configure Hotspot to use RADIUS"
    }
}

# ---------- PPP AAA ----------
:do {
    /ppp aaa set use-radius=yes accounting=yes interim-update=1h
} on-error={:put "Warning: Could not configure PPP AAA"}

# ---------- API Configuration ----------
:put "==================== API CONFIGURATION ===================="

# Configure API user with secure settings
:local userExists [/user find name=$username]
:if ([:len $userExists] > 0) do={
    /user set [find name=$username] password=$password group=full disabled=no \
        comment="ZiSP API User - Auto-generated" address=$trustedIp
    :put "API user updated: $username"
} else={
    /user add name=$username password=$password group=full disabled=no \
        comment="ZiSP API User - Auto-generated" address=$trustedIp
    :put "API user created: $username"
}

# Enable API service with secure settings
:do {
    /ip service disable api
    /ip service disable api-ssl
    
    # Configure API service
    /ip service set api disabled=no port=$apiPort address=$trustedIp \
        certificate=none tls-version=only-1.2
    
    :put "API service enabled on port $apiPort (restricted to $trustedIp)"
} on-error={
    :put "Warning: API service configuration failed"
}

# ---------- Firewall Configuration ----------
:put "==================== FIREWALL CONFIGURATION ===================="

# Function to safely add firewall rules with proper ordering
:local addFirewallRule do={
    :local chain [$1]
    :local action [$2]
    :local comment [$3]
    :local rule [:parse "$4"]
    
    :local ruleId [find where (chain=$chain) && (comment=$comment)]
    :if ([:len $ruleId] > 0) do={
        /ip firewall filter set $ruleId $rule
        :put "Updated firewall rule: $comment"
    } else={
        /ip firewall filter add chain=$chain action=$action comment=$comment $rule
        :put "Added firewall rule: $comment"
    }
}

# Remove old rules
:do { /ip firewall filter remove [find comment~"^zisp-"] } on-error={}

# Base rules for trusted IP (API access)
:do {
    # Allow established/related connections
    :set $rule "connection-state=established,related"
    $addFirewallRule "input" "accept" "zisp-established" $rule
    $addFirewallRule "output" "accept" "zisp-established" $rule
    
    # Allow ICMP (ping)
    :set $rule "protocol=icmp"
    $addFirewallRule "input" "accept" "zisp-icmp" $rule
    
    # Allow SSH from trusted IP (if SSH is enabled)
    :set $rule "protocol=tcp dst-port=22 src-address=$trustedIp"
    $addFirewallRule "input" "accept" "zisp-ssh" $rule
    
    # Allow API access from trusted IP
    :if ([:len $apiPort] > 0) do={
        :set $rule "protocol=tcp dst-port=$apiPort src-address=$trustedIp"
        $addFirewallRule "input" "accept" "zisp-api" $rule
    }
    
    # Allow RADIUS traffic
    :if ([:len $radiusIp] > 0) do={
        # RADIUS authentication
        :set $rule "protocol=udp dst-port=1812 src-address=$radiusIp"
        $addFirewallRule "input" "accept" "zisp-radius-auth" $rule
        
        # RADIUS accounting
        :set $rule "protocol=udp dst-port=1813 src-address=$radiusIp"
        $addFirewallRule "input" "accept" "zisp-radius-acct" $rule
        
        # RADIUS client (outgoing)
        :set $rule "protocol=udp dst-address=$radiusIp dst-port=1812,1813"
        $addFirewallRule "output" "accept" "zisp-radius-out" $rule
    }
    
    # WireGuard rules
    :if ([:len $wgServerEndpoint] > 0 && [:len $wgPort] > 0) do={
        # Resolve WG server endpoint to IP (if hostname provided)
        :local wgServerIp ""
        :do { :set wgServerIp [:resolve $wgServerEndpoint] } on-error={}
        
        # Allow outgoing UDP to WireGuard server
        :if ([:len $wgServerIp] > 0) do={
            :set $rule "protocol=udp dst-address=$wgServerIp dst-port=$wgPort"
        } else={
            :set $rule "protocol=udp dst-port=$wgPort"
        }
        $addFirewallRule "output" "accept" "zisp-wg-out" $rule
        
        # Allow incoming WireGuard traffic
        :if ([:len $wgServerIp] > 0) do={
            :set $rule "protocol=udp src-address=$wgServerIp dst-port=$wgPort"
        } else={
            :set $rule "protocol=udp dst-port=$wgPort"
        }
        $addFirewallRule "input" "accept" "zisp-wg-in" $rule
        
        # Allow traffic on WireGuard interface
        :set $rule "in-interface=zisp-wg"
        $addFirewallRule "input" "accept" "zisp-wg-interface" $rule
        
        # Allow forwarding to/from WireGuard interface
        :set $rule "in-interface=zisp-wg"
        $addFirewallRule "forward" "accept" "zisp-wg-forward" $rule
        :set $rule "out-interface=zisp-wg"
        $addFirewallRule "forward" "accept" "zisp-wg-forward-out" $rule
    }
    
    # Default deny rules (with logging for debugging)
    :set $rule "connection-state=new log-prefix=\"ZISP-DROP: \""
    $addFirewallRule "input" "drop" "zisp-deny-input" $rule
    $addFirewallRule "forward" "drop" "zisp-deny-forward" $rule
    
    :put "Firewall configuration completed successfully"
} on-error={
    :put "Warning: Error during firewall configuration: $error"
}


# ---------- WireGuard Setup ----------
:put "==================== WIREGUARD SETUP ===================="

:if ([:len $wgServerPubKey] > 0 && [:len $wgServerEndpoint] > 0) do={
    :put "WireGuard server info present, setting up interface..."

    # Remove existing interface
    :do { /interface wireguard remove [find name="zisp-wg"] } on-error={}

    # Create WG interface (listen on configured port)
    :do { /interface wireguard add name="zisp-wg" listen-port=$wgPort disabled=no } on-error={ :put "Failed to create WireGuard interface" }

    # Optionally assign a static IP to the WG interface if provided (e.g., 10.10.0.2/32)
    :if ([:len $wgClientIp] > 0) do={
        :do { /ip address add interface="zisp-wg" address=$wgClientIp } on-error={ :put "Warning: Failed to assign WG client IP" }
    }

    # Generate keys (RouterOS v7+ supports private-key property)
    :local privKey [/interface wireguard get [find name="zisp-wg"] private-key]
    :local pubKey [/interface wireguard get [find name="zisp-wg"] public-key]

    :put "WireGuard keys generated (public key only):"
    :put " - Public: $pubKey"

    # Add server peer
    :do {
        /interface wireguard peers add interface="zisp-wg" public-key=$wgServerPubKey endpoint-address=$wgServerEndpoint endpoint-port=$wgPort allowed-address=$wgSubnet persistent-keepalive=25
        :put "Added peer to WireGuard server $wgServerEndpoint:$wgPort"
    } on-error={ :put "Warning: Failed to add server peer" }

    # Determine local WireGuard IP (prefer provided wgClientIp)
    :local wgAddr ""
    :if ([:len $wgClientIp] > 0) do={
        :local slashPos [:find $wgClientIp "/"]
        :if ($slashPos = -1) do={ :set wgAddr $wgClientIp } else={ :set wgAddr [:pick $wgClientIp 0 $slashPos] }
    } else={
        :do {
            :local addrIds [/ip address find interface="zisp-wg"]
            :foreach id in=$addrIds do={
                :local fullAddr [/ip address get $id address]
                :local slashPos2 [:find $fullAddr "/"]
                :if ($slashPos2 = -1) do={ :set wgAddr $fullAddr } else={ :set wgAddr [:pick $fullAddr 0 $slashPos2] }
            }
        } on-error={}
    }

    # Phone-home WireGuard registration (POST to register endpoint with token)
    :if ([:len $wgRegisterUrl] > 0) do={
        :local postData ("wg_public_key=" . $pubKey)
        :if ([:len $wgAddr] > 0) do={ :set postData ($postData . "&wg_address=" . $wgAddr) }
        :do {
            :put ("Attempting WireGuard register POST to: " . $wgRegisterUrl)
            /tool fetch url=$wgRegisterUrl http-method=post http-data=$postData keep-result=no
            :put "WireGuard register phone-home successful"
        } on-error={
            :put "Warning: WireGuard register phone-home failed over HTTPS; attempting HTTP fallback"
            :local altUrl $wgRegisterUrl
            :if ([:len $altUrl] > 8 && [:pick $altUrl 0 8] = "https://") do={
                :set altUrl ("http://" . [:pick $altUrl 8 [:len $altUrl]])
            }
            :do {
                :put ("Attempting WireGuard register POST to (fallback): " . $altUrl)
                /tool fetch url=$altUrl http-method=post http-data=$postData keep-result=no
                :put "WireGuard register phone-home successful (HTTP fallback)"
            } on-error={ :put "Warning: WireGuard register phone-home failed (both HTTPS and HTTP)" }
        }
    } else={
        :put "No WireGuard register URL configured; skipping WG register phone-home"
    }
} else={
    :put "WireGuard server info missing; skipping WG setup"
}

# ---------- Periodic Phone-home Script ----------
:if ([:len $syncUrl] > 0) do={
    :do { /system script remove [find name="zisp-phone-home"] } on-error={}
    /system script add name="zisp-phone-home" source={
        :local routerIp ""
        :foreach id in=[/ip address find] do={
            :local ipAddr [/ip address get $id address]
            :local ipOnly [:pick $ipAddr 0 [:find $ipAddr "/"]]
            :if ([:pick $ipOnly 0 3] != "127" && [:len $routerIp] = 0) do={
                :set routerIp $ipOnly
            }
        }

        :local boardName ""
        :local routerOsVersion ""
        :local routerModel ""
        :do { :set boardName [/system routerboard get board-name] } on-error={}
        :do { :set routerOsVersion [/system resource get version] } on-error={}
        :do { :set routerModel [/system resource get board-name] } on-error={}

        :if ([:len $routerIp] > 0) do={
            :local postData ("ip_address=" . $routerIp)
            :if ([:len $boardName] > 0) do={
                :set postData ($postData . "&board_name=" . [:pick $boardName 0 200])
            }
            :if ([:len $routerOsVersion] > 0) do={
                :set postData ($postData . "&system_version=" . [:pick $routerOsVersion 0 200])
            }
            :if ([:len $routerModel] > 0) do={
                :set postData ($postData . "&router_model=" . [:pick $routerModel 0 200])
            }
            /tool fetch url="{{sync_url}}" http-method=post http-data=$postData keep-result=no
        }
    }
    :do { /system scheduler remove [find name="zisp-phone-home"] } on-error={}
    /system scheduler add name="zisp-phone-home" start-time=startup interval=3m on-event="/system script run zisp-phone-home" comment="ZiSP periodic phone-home"
    :put "Periodic phone-home configured (every 3 minutes)"
} else={ :put "No sync URL configured for phone-home" }

:put "==================== ONBOARDING COMPLETE ===================="
:put "Router connected to ZiSP system"
:put "API User: $username"
:put "API Port: $apiPort"
:put "WireGuard setup: Completed (if RouterOS v7+)"
