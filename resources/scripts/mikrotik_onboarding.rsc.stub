# ================= ZiSP RouterOS v7+ Onboarding Script =================
# Generated for router: {{name}}
# Router ID: {{router_id}}

# ---------- Version Check ----------
:local version [/system resource get version]
:local majorVersion [:pick $version 0 1]

:if ($majorVersion < 7) do={
    :put "========================================================"
    :put "ERROR: RouterOS v7+ is required!"
    :put "Current version: $version"
    :put "Please upgrade your router to RouterOS v7 to use this script."
    :put "========================================================"
    :error "Script cancelled: RouterOS upgrade required."
}

:local username "{{username}}"
:local password "{{router_password}}"
:local apiUsername "{{api_username}}"
:local apiPassword "{{api_password}}"
:local apiPort "{{api_port}}"
:local radiusSecret "{{radius_secret}}"
:local radiusServerIp "{{radius_vpn_ip}}"
# RADIUS reachable via VPN tunnel (10.100.0.1)
:local radiusIp $radiusServerIp
:local trustedIp "{{trusted_ip}}"
:local wgServerEndpoint "{{wg_server_endpoint}}"
:local wgServerPubKey "{{wg_server_pubkey}}"
:local wgSubnet "{{wg_subnet}}"
:local wgPort "{{wg_port}}"
:local wgClientIp "{{wg_client_ip}}"
:local wgRegisterUrl "{{wg_register_url}}"

:put "==================== ZiSP MIKROTIK ONBOARDING ===================="

# ---------- Connectivity check ----------
:if ([/ping 8.8.8.8 count=3] = 0) do={
    :return "No internet connection. Try again after checking."
}

# ---------- Router Identity ----------
/system identity set name="{{name}}"
:put " === Router identity set to: {{name}} === "

# ---------- Display Router IPs ----------
:put " === Router IP addresses: === "
:foreach id in=[/ip address find] do={
    :local ipAddr [/ip address get $id address]
    :put " - $ipAddr"
}

:put " ======= Applying Radius Configuration ======= "
:do {
    /radius remove [find address=$radiusIp]
    :if ($radiusServerIp != $radiusIp) do={
        /radius remove [find address=$radiusServerIp]
    }
} on-error={}

:local radiusServices "ppp"
:do {
    /ip hotspot print
    :set radiusServices "ppp,hotspot"
} on-error={}

:do {
    /radius add service=$radiusServices address=$radiusServerIp secret=$radiusSecret disabled=no timeout=3000ms accounting-port=1813 authentication-port=1812
    :if ($radiusServerIp != $radiusIp) do={
        :put "RADIUS configured: $radiusServices (via VPN $radiusServerIp)"
    } else={
        :put " ======= RADIUS configured: $radiusServices ======= "
    }
} on-error={
    :put " !!!! Warning: Could not configure RADIUS !!!!! "
}

# ---------- PPP AAA ----------
:do {
    /ppp aaa set use-radius=yes accounting=yes interim-update=1h
} on-error={:put "Warning: Could not configure PPP AAA"}

# ---------- API User (Dedicated zisp_user) ----------
:local apiUserExists [/user find name=$apiUsername]
:if ([:len $apiUserExists] > 0) do={
    /user set [find name=$apiUsername] password=$apiPassword group=full disabled=no comment="ZiSP API User"
    :put "API user updated: $apiUsername"
} else={
    /user add name=$apiUsername password=$apiPassword group=full disabled=no comment="ZiSP API User"
    :put "API user created: $apiUsername"
}

# ---------- Firewall Rules for Trusted IP ----------
:do {
    /ip firewall filter remove [find comment="zisp-api"]
} on-error={}
:do {
    /ip firewall filter add chain=input action=accept src-address=$trustedIp comment="zisp-api"
    /ip firewall filter add chain=output action=accept dst-address=$trustedIp comment="zisp-api"

    # Remove previous WireGuard-related rules to avoid duplicates
    :do { /ip firewall filter remove [find comment~"zisp-wg"] } on-error={}
    :do { /ip firewall nat remove [find comment~"zisp-wg"] } on-error={}

    # Resolve WG server endpoint to IP (if hostname provided)
    :local wgServerIp ""
    :do { :set wgServerIp [:resolve $wgServerEndpoint] } on-error={}

    # ========== FIREWALL FILTER RULES ==========
    
    # Allow outgoing UDP to WireGuard server (if IP resolved), otherwise allow by port only
    :if ([:len $wgServerIp] > 0) do={
        /ip firewall filter add chain=output action=accept protocol=udp dst-address=$wgServerIp dst-port=$wgPort comment="zisp-wg-output"
        /ip firewall filter add chain=input action=accept protocol=udp src-address=$wgServerIp dst-port=$wgPort comment="zisp-wg-input"
    } else={
        /ip firewall filter add chain=output action=accept protocol=udp dst-port=$wgPort comment="zisp-wg-output"
        /ip firewall filter add chain=input action=accept protocol=udp dst-port=$wgPort comment="zisp-wg-input"
    }
    
    # Allow all traffic on WireGuard interface (input chain)
    /ip firewall filter add chain=input action=accept in-interface="zisp-wireguard" comment="zisp-wg-interface-input"
    
    # Allow established and related connections for WireGuard
    /ip firewall filter add chain=forward action=accept connection-state=established,related in-interface="zisp-wireguard" comment="zisp-wg-forward-established"
    /ip firewall filter add chain=forward action=accept connection-state=established,related out-interface="zisp-wireguard" comment="zisp-wg-forward-established-out"
    
    # Allow forwarding FROM WireGuard tunnel to LAN
    /ip firewall filter add chain=forward action=accept in-interface="zisp-wireguard" comment="zisp-wg-forward-in"
    
    # Allow forwarding FROM LAN to WireGuard tunnel
    /ip firewall filter add chain=forward action=accept out-interface="zisp-wireguard" comment="zisp-wg-forward-out"

    # ========== NAT MASQUERADE RULES ==========
    
    # Get the WAN interface name (first interface that has a gateway)
    :local wanInterface ""
    :foreach route in=[/ip route find where gateway!="" and dst-address="0.0.0.0/0"] do={
        :set wanInterface [/ip route get $route gateway]
        # Extract interface name if gateway is an interface
        :if ([:typeof $wanInterface] = "str") do={
            :local ifList [/interface find name=$wanInterface]
            :if ([:len $ifList] > 0) do={
                :set wanInterface $wanInterface
            } else={
                # Gateway is an IP, find the interface
                :foreach iface in=[/interface find] do={
                    :local ifName [/interface get $iface name]
                    :foreach addr in=[/ip address find interface=$ifName] do={
                        :local network [/ip address get $addr network]
                        :if ([:typeof [:find [:tostr $wanInterface] [:tostr $network]]] != "nil") do={
                            :set wanInterface $ifName
                        }
                    }
                }
            }
        }
    }
    
    # If we couldn't determine WAN interface automatically, use ether1 as fallback
    :if ([:len $wanInterface] = 0) do={
        :set wanInterface "ether1"
        :put "Warning: Could not auto-detect WAN interface, using ether1 as default"
    }
    
    :put ("Detected WAN interface: " . $wanInterface)
    
    # Masquerade traffic from WireGuard to WAN (allows VPN clients to access internet through this router)
    /ip firewall nat add chain=srcnat action=masquerade out-interface=$wanInterface src-address=10.100.0.0/16 comment="zisp-wg-masquerade-wan"
    
    # Masquerade traffic from LAN to WireGuard (allows LAN devices to communicate with VPN network)
    /ip firewall nat add chain=srcnat action=masquerade out-interface="zisp-wireguard" comment="zisp-wg-masquerade-vpn"

    :put "Firewall and NAT rules configured successfully"
} on-error={
    :put "Warning: Firewall/NAT configuration failed"
}

# ---------- Enable API Service ----------
:do {
    :local apiAllowedIps "$trustedIp,$radiusServerIp"
/ip service set api disabled=no port=$apiPort address=$apiAllowedIps
    :put "API service enabled on port $apiPort (restricted to $trustedIp)"
} on-error={
    :put "Warning: API service configuration failed"
}

# ---------- Enable Winbox Service ----------
:do {
    :local winboxPort "{{winbox_port}}"
    /ip service set winbox disabled=no port=$winboxPort address=""
    :put "Winbox service enabled on port $winboxPort (accessible from anywhere)"
} on-error={
    :put "Warning: Winbox service configuration failed"
}

:put "==================== WIREGUARD SETUP ===================="

:if ([:len $wgServerPubKey] > 0 && [:len $wgServerEndpoint] > 0) do={
    :put "WireGuard server info present, setting up interface..."

    # Remove existing interface
    :do { /interface wireguard remove [find name="zisp-wireguard"] } on-error={}

    # Create WG interface (listen on configured port)
    :do { /interface wireguard add name="zisp-wireguard" listen-port=$wgPort disabled=no } on-error={ :put "Failed to create WireGuard interface" }

:if ([:len $wgClientIp] = 0) do={
    :put ("Error: wgClientIp is empty")
} else={

    # Ensure there's a /16 mask
    :local clientIpWithMask $wgClientIp
    :if ([:typeof [:find $clientIpWithMask "/"]] = "nil") do={
        :set clientIpWithMask ($clientIpWithMask . "/16")
    }

    :if ([:typeof [:find $clientIpWithMask "10.100."]] = "nil") do={
        :put ("Error: " . $clientIpWithMask . " is not in the 10.100.0.0/16 subnet")
    } else={

        # Remove ALL existing WireGuard IP addresses (by comment) to prevent duplicates
        :put "Removing any existing WireGuard IP addresses..."
        :do {
            :foreach addr in=[/ip/address/find where comment="wireguard assigned by registration script"] do={
                :local oldAddr [/ip/address/get $addr address]
                /ip/address/remove $addr
                :put ("Removed old WireGuard IP: " . $oldAddr)
            }
        } on-error={
            :put "Warning: Could not remove old WireGuard addresses"
        }

        # Now add the new address
        :do {
            /ip/address/add interface="zisp-wireguard" address=$clientIpWithMask comment="wireguard assigned by registration script"
            :put ("Success: added " . $clientIpWithMask . " to interface zisp-wireguard")
        } on-error={
            :local errStr ("Failed to add " . $clientIpWithMask)
            :put $errStr
            /log warning $errStr
        }
    }
}

    # Generate keys (RouterOS v7+ supports private-key property)
    :local privKey [/interface wireguard get [find name="zisp-wireguard"] private-key]
    :local pubKey [/interface wireguard get [find name="zisp-wireguard"] public-key]

    :put "WireGuard keys generated (public key only):"
    :put " - Public: $pubKey"

    # Add server peer
    :do {
        /interface wireguard peers add interface="zisp-wireguard" public-key=$wgServerPubKey endpoint-address=$wgServerEndpoint endpoint-port=$wgPort allowed-address=$wgSubnet persistent-keepalive=25
        :put "Added peer to WireGuard server $wgServerEndpoint:$wgPort"
    } on-error={ :put "Warning: Failed to add server peer" }

    # Determine local WireGuard IP (prefer provided wgClientIp)
    :local wgAddr ""
    :if ([:len $wgClientIp] > 0) do={
        :local slashPos [:find $wgClientIp "/"]
        :if ($slashPos = -1) do={ :set wgAddr $wgClientIp } else={ :set wgAddr [:pick $wgClientIp 0 $slashPos] }
    } else={
        :do {
            :local addrIds [/ip address find interface="zisp-wg"]
            :foreach id in=$addrIds do={
                :local fullAddr [/ip address get $id address]
                :local slashPos2 [:find $fullAddr "/"]
                :if ($slashPos2 = -1) do={ :set wgAddr $fullAddr } else={ :set wgAddr [:pick $fullAddr 0 $slashPos2] }
            }
        } on-error={}
    }

    # Get router model information for registration
    :local routerModel ""
:local routerArch ""
:local routerVersion ""
    :do {
        :set routerModel [/system resource get board-name]
        :set routerArch [/system resource get architecture-name]
        :set routerVersion [/system resource get version]
    } on-error={}

    # Phone-home WireGuard registration (POST to register endpoint with token)
    :if ([:len $wgRegisterUrl] > 0) do={
        :local postData ("wg_public_key=" . $pubKey)
        :if ([:len $wgAddr] > 0) do={ :set postData ($postData . "&wg_address=" . $wgAddr) }
        :if ([:len $routerModel] > 0) do={ :set postData ($postData . "&router_model=" . $routerModel) }
        :if ([:len $routerArch] > 0) do={ :set postData ($postData . "&router_arch=" . $routerArch) }
        :if ([:len $routerVersion] > 0) do={ :set postData ($postData . "&router_version=" . $routerVersion) }
        :do {
            :put ("Attempting WireGuard register POST to: " . $wgRegisterUrl)
            :put ("  POST data: wg_public_key=<KEY>&wg_address=" . $wgAddr . "&router_model=" . $routerModel)
            /tool fetch url=$wgRegisterUrl http-method=post http-data=$postData http-header-field="Content-Type: application/x-www-form-urlencoded" keep-result=no
            :put "  status: success"
            :put "WireGuard register phone-home successful"
        } on-error={
            :put "  status: failed"
            :put "Warning: WireGuard register phone-home failed over HTTPS; attempting HTTP fallback"
            :local altUrl $wgRegisterUrl
            :if ([:len $altUrl] > 8 && [:pick $altUrl 0 8] = "https://") do={
                :set altUrl ("http://" . [:pick $altUrl 8 [:len $altUrl]])
            }
            :do {
                :put ("Attempting WireGuard register POST to (fallback): " . $altUrl)
                /tool fetch url=$altUrl http-method=post http-data=$postData http-header-field="Content-Type: application/x-www-form-urlencoded" keep-result=no
                :put "  status: success"
                :put "WireGuard register phone-home successful (HTTP fallback)"
            } on-error={ 
                :put "  status: failed"
                :put "Warning: WireGuard register phone-home failed (both HTTPS and HTTP)" 
            }
        }
    } else={
        :put "No WireGuard register URL configured; skipping WG register phone-home"
    }
} else={
    :put "WireGuard server info missing; skipping WG setup"
}

:do {
    /system clock
    set time-zone-name=Africa/Nairobi
} on-error={
    :put "Warning: Could not set timezone"
}
:put " ======= Timezone Configured ======= "



:put " =================== Creating reboot scheduler =================== "
:do {
    /system scheduler remove [find name="zisp-reboot-3am"]
} on-error={}
/system scheduler add name="zisp-reboot-3am" start-time=03:00:00 interval=1d on-event="/system reboot" comment="ZiSP Daily Reboot at 3AM"
:put " =================== Reboot scheduler created =================== "


:put "==================== ONBOARDING COMPLETE ===================="
:put "Router connected to ZiSP system"
:put "API User: $apiUsername"
:put "API Port: $apiPort"


:put " ======= zisp Onboarding successful ======== "
